# AI 工具调用文本重复问题修复说明

## 问题描述

用户在使用 AI 聊天时，当 AI 使用工具时，工具调用前的描述性文本会在 UI 中重复显示两次：
1. 第一次在 `<tool_call>` 标签之前
2. 第二次在 `</tool_call>` 标签之后、`<tool_result>` 标签之前

例如：
```
好的！没问题。我们来一起看看 myfile.xlsx 文件里有什么。
首先，我要用一个工具来查看这个文件有哪些工作簿（就像书里的章节一样）。
我会用到 get_workbook_metadata 这个工具。

<tool_call>...</tool_call>

好的！没问题。我们来一起看看 myfile.xlsx 文件里有什么。  ← 重复！
首先，我要用一个工具来查看这个文件有哪些工作簿（就像书里的章节一样）。  ← 重复！
我会用到 get_workbook_metadata 这个工具。  ← 重复！

<tool_result>...</tool_result>
```

## 根本原因

在 `rust-lib/flowy-ai/src/chat.rs` 的流式处理逻辑中，存在文本重复发送的问题：

### 问题流程：

1. AI 开始回复："好的！没问题..."（作为 `value` 通过第 535 行立即发送）
2. AI 继续回复："我会用到 get_workbook_metadata..."（作为 `value` 通过第 535 行立即发送）
3. AI 返回 `<tool_call>...</tool_call>`（检测到完整工具调用）
4. 此时 `accumulated_text` 包含了步骤 1、2、3 的所有内容
5. 第 369-374 行再次发送 `before_text`（即工具调用之前的所有文本）
6. **结果：步骤 1 和 2 的内容被重复发送！**

### 代码问题：

**问题代码：**
```rust
// 当还没有检测到完整工具调用时
} else {
  // 立即发送每个数据片段
  answer_stream_buffer.lock().await.push_str(&value);
  if let Err(err) = answer_sink
    .send(StreamMessage::OnData(value).to_string())
    .await
  {
    error!("Failed to stream answer via IsolateSink: {}", err);
  }
}

// 当检测到完整工具调用时
for (request, start, end) in calls {
  // 再次发送工具调用之前的所有文本（包括已经发送过的！）
  let before_text = &accumulated_text[..start];
  if !before_text.is_empty() {
    answer_stream_buffer.lock().await.push_str(before_text);
    let _ = answer_sink
      .send(StreamMessage::OnData(before_text.to_string()).to_string())
      .await;
  }
}
```

## 修复方案

引入 `sent_text_length` 变量来跟踪已发送的文本长度，确保每段文本只发送一次。

### 修复内容：

1. **添加跟踪变量**（第 270 行）：
```rust
let mut sent_text_length: usize = 0;  // 跟踪已发送的文本长度
```

2. **修复工具调用检测后的处理**（第 374-382 行）：
```rust
// 只发送还没有发送过的文本（避免重复发送）
// 如果工具调用之前还有未发送的文本，则发送它
if sent_text_length < start {  // ← 关键：边界检查，避免越界
  let unsent_text = &accumulated_text[sent_text_length..start];
  info!("🔧 [TOOL] Sending unsent text before tool call (length: {})", unsent_text.len());
  answer_stream_buffer.lock().await.push_str(unsent_text);
  let _ = answer_sink
    .send(StreamMessage::OnData(unsent_text.to_string()).to_string())
    .await;
  sent_text_length = start;  // 更新已发送长度
}
```

3. **修复 else 分支的处理**（第 550-561 行）：
```rust
} else {
  // 没有检测到完整工具调用，发送新增的文本（避免重复发送）
  let unsent_text = &accumulated_text[sent_text_length..];  // ← 只发送新增部分
  if !unsent_text.is_empty() {
    answer_stream_buffer.lock().await.push_str(unsent_text);
    if let Err(err) = answer_sink
      .send(StreamMessage::OnData(unsent_text.to_string()).to_string())
      .await
    {
      error!("Failed to stream answer via IsolateSink: {}", err);
    }
    sent_text_length = accumulated_text.len();  // 更新已发送长度
  }
}
```

4. **支持多个工具调用**（第 368-369 行，533-548 行）：
```rust
// 记录最后一个工具调用的结束位置
let mut last_tool_end_pos = 0;

for (request, start, end) in calls {
  // ... 处理工具调用 ...
  last_tool_end_pos = end;  // 记录结束位置
}

// 处理完所有工具调用后，统一清除已处理的文本
if last_tool_end_pos > 0 {
  accumulated_text = accumulated_text[last_tool_end_pos..].to_string();
  sent_text_length = 0;  // 重置已发送长度
  
  // 发送剩余文本（所有工具调用之后的文本）
  if !accumulated_text.is_empty() {
    // ...
  }
}
```

## 关键修复点：边界检查

### 问题：
初始修复中出现了 `byte index out of bounds` 错误，因为：
- `sent_text_length` 跟踪的是 `accumulated_text` 的已发送长度
- `start` 是工具调用在 `accumulated_text` 中的开始位置
- 当 `sent_text_length >= start` 时，说明工具调用之前的文本已经全部发送过了
- 如果直接切片 `&before_text[sent_text_length..]` 会导致越界

### 解决方案：
添加边界检查 `if sent_text_length < start`，只在有未发送文本时才进行切片和发送操作。

## 测试验证

### 编译检查：
```bash
cd rust-lib && cargo check --package flowy-ai
```
✅ 编译成功，无错误

### 预期效果：

修复后，工具调用前的描述性文本只会显示一次：

```
好的！没问题。我们来一起看看 myfile.xlsx 文件里有什么。
首先，我要用一个工具来查看这个文件有哪些工作簿（就像书里的章节一样）。
我会用到 get_workbook_metadata 这个工具。

<tool_call>...</tool_call>

<tool_result>...</tool_result>

[后续 AI 回答...]
```

## 修改的文件

- `rust-lib/flowy-ai/src/chat.rs`
  - 添加 `sent_text_length` 变量跟踪已发送文本
  - 修复工具调用检测后的文本发送逻辑
  - 修复正常流式发送的逻辑
  - 支持多个工具调用的正确处理

## 后续步骤

1. 重新编译 Rust 库
2. 重新构建 Flutter 应用
3. 测试工具调用场景，验证文本不再重复

## 构建命令

```bash
# 1. 编译 Rust 库
cd rust-lib/dart-ffi
cargo build --release

# 2. 重新运行 Flutter 应用
cd ../../appflowy_flutter
flutter run -d macos
```

